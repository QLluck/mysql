### 实验过程
本次实验围绕视图和索引展开，首先创建不同类型的视图（单表视图、多表关联视图、聚合视图），通过视图进行数据更新操作并验证视图更新的限制，最后学习索引的创建、修改和删除，理解视图和索引在数据库中的作用及使用场景。

### 实验详细操作步骤或程序清单
```sql
USE School;

-- （1）定义信息系学生基本情况视图V_IS
CREATE VIEW V_IS AS
SELECT sno, sname, sage, ssex, sdept
FROM student
WHERE sdept = 'IS';

-- （2）定义学生学号、姓名、课程号、课程名、成绩视图V_S_C_G
CREATE VIEW V_S_C_G AS
SELECT s.sno, s.sname, c.cno, c.cname, sc.Grade
FROM student s
JOIN sc ON s.sno = sc.sno
JOIN course c ON sc.cno = c.cno;

-- （3）定义各系学生人数、平均年龄视图V_NUM_AVG
CREATE VIEW V_NUM_AVG AS
SELECT sdept, COUNT(sno) AS 学生人数, AVG(sage) AS 平均年龄
FROM student
GROUP BY sdept;

-- （4）定义学生学号、选修门数及平均成绩视图V_AVG_S_G
CREATE VIEW V_AVG_S_G AS
SELECT sno, COUNT(cno) AS 选修门数, AVG(Grade) AS 平均成绩
FROM sc
GROUP BY sno;

-- （5）定义各门课程号、选修人数及平均成绩视图V_AVG_C_G
CREATE VIEW V_AVG_C_G AS
SELECT cno, COUNT(sno) AS 选修人数, AVG(Grade) AS 平均成绩
FROM sc
GROUP BY cno;

-- （6）视图更新操作
-- 1）通过V_IS修改学号08001的姓名为“张小立”
UPDATE V_IS SET sname = '张小立' WHERE sno = '08001';
SELECT * FROM V_IS WHERE sno = '08001'; -- 查看结果

-- 2）通过V_IS新增学生记录
INSERT INTO V_IS (sno, sname, sage, ssex, sdept)
VALUES ('08030', '李莉', 18, '女', 'IS');
SELECT * FROM V_IS WHERE sno = '08030'; -- 查看结果

-- 3）通过V_IS删除学号08030的学生
DELETE FROM V_IS WHERE sno = '08030';
SELECT * FROM V_IS WHERE sno = '08030'; -- 查看结果

-- 4）尝试通过V_S_C_G修改学号08002的姓名为“刘晓晨”
UPDATE V_S_C_G SET sname = '刘晓晨' WHERE sno = '08002'; -- 执行后观察结果

-- 5）尝试通过V_AVG_S_G修改学号08003的平均成绩为90
UPDATE V_AVG_S_G SET 平均成绩 = 90 WHERE sno = '08003'; -- 执行后观察结果

-- （7）查询平均成绩90分以上的学生学号、姓名和成绩
SELECT vasg.sno, s.sname, sc.Grade
FROM V_AVG_S_G vasg
JOIN student s ON vasg.sno = s.sno
JOIN sc ON vasg.sno = sc.sno
WHERE vasg.平均成绩 >= 90;

-- （8）查询成绩大于课程平均成绩的学生学号、课程号和成绩
SELECT sc.sno, sc.cno, sc.Grade
FROM sc
JOIN V_AVG_C_G vacg ON sc.cno = vacg.cno
WHERE sc.Grade > vacg.平均成绩;

-- （9）按系分组统计平均成绩80分以上的人数，降序排列
SELECT s.sdept, COUNT(DISTINCT s.sno) AS 人数
FROM student s
JOIN V_AVG_S_G vasg ON s.sno = vasg.sno
WHERE vasg.平均成绩 >= 80
GROUP BY s.sdept
ORDER BY 人数 DESC;

-- （10）为student表创建复合索引i_sdept_sno（院系升序、学号降序）
CREATE INDEX i_sdept_sno ON student(sdept ASC, sno DESC);

-- （11）在student表的sname列上建立普通降序索引
CREATE INDEX idx_sname ON student(sname DESC);

-- （12）在course表的cname列上建立唯一索引
CREATE UNIQUE INDEX idx_cname ON course(cname);

-- （13）修改索引名称（MySQL需先删除再重建，或用ALTER）
-- MySQL中直接修改索引名需先删除原索引，再重建新索引
DROP INDEX i_sdept_sno ON student;
CREATE INDEX i_s ON student(sdept ASC, sno DESC);

-- （14）删除索引i_s
DROP INDEX i_s ON student;
```

### 疑难小结
1. **视图更新限制**：多表关联视图（如V_S_C_G）无法直接更新，因为数据库无法确定要修改的是哪个基表的数据；聚合视图（如V_AVG_S_G）因包含分组和聚合函数，也不支持更新。
2. **索引重命名问题**：MySQL中没有直接重命名索引的语句，需先删除原索引再重建，而其他数据库（如SQL Server）支持`SP_RENAME`，需注意数据库语法差异。
3. **唯一索引约束**：在course表的cname列创建唯一索引后，插入重复课程名会报错，需确保数据唯一性。
4. **视图查询性能**：视图本身不存储数据，查询视图本质是查询基表，复杂视图可能影响性能，需结合索引优化。

### 实验结果
1. 成功创建各类视图，单表视图（V_IS）支持增删改操作，多表关联视图和聚合视图不支持更新，验证了视图更新的限制。
2. 通过视图实现了复杂数据查询（如平均成绩筛选、按系统计），简化了查询语句。
3. 完成索引的创建、修改和删除，理解了普通索引、唯一索引、复合索引的区别及使用场景。
4. 明确了视图的作用（简化查询、数据安全）和索引的作用（提升查询性能），掌握了两者的核心操作。